# coding: utf-8

"""
    Asana

    This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from asana_asyncio.models.custom_field_setting_response import CustomFieldSettingResponse
from asana_asyncio.models.project_base_all_of_current_status import ProjectBaseAllOfCurrentStatus
from asana_asyncio.models.project_base_all_of_current_status_update import ProjectBaseAllOfCurrentStatusUpdate
from asana_asyncio.models.user_compact import UserCompact
from typing import Optional, Set
from typing_extensions import Self

class ProjectBase(BaseModel):
    """
    ProjectBase
    """ # noqa: E501
    gid: Optional[StrictStr] = Field(default=None, description="Globally unique identifier of the resource, as a string.")
    resource_type: Optional[StrictStr] = Field(default=None, description="The base type of this resource.")
    name: Optional[StrictStr] = Field(default=None, description="Name of the project. This is generally a short sentence fragment that fits on a line in the UI for maximum readability. However, it can be longer.")
    archived: Optional[StrictBool] = Field(default=None, description="True if the project is archived, false if not. Archived projects do not show in the UI by default and may be treated differently for queries.")
    color: Optional[StrictStr] = Field(default=None, description="Color of the project.")
    created_at: Optional[datetime] = Field(default=None, description="The time at which this resource was created.")
    current_status: Optional[ProjectBaseAllOfCurrentStatus] = None
    current_status_update: Optional[ProjectBaseAllOfCurrentStatusUpdate] = None
    custom_field_settings: Optional[List[CustomFieldSettingResponse]] = Field(default=None, description="<p><strong style=\"color: #4573D2\">Full object requires scope: </strong><code>custom_fields:read</code></p>  Array of Custom Field Settings (in compact form).")
    default_view: Optional[StrictStr] = Field(default=None, description="The default view (list, board, calendar, or timeline) of a project.")
    due_date: Optional[date] = Field(default=None, description="*Deprecated: new integrations should prefer the `due_on` field.*")
    due_on: Optional[date] = Field(default=None, description="The day on which this project is due. This takes a date with format YYYY-MM-DD.")
    html_notes: Optional[StrictStr] = Field(default=None, description="[Opt In](/docs/inputoutput-options). The notes of the project with formatting as HTML.")
    members: Optional[List[UserCompact]] = Field(default=None, description="Array of users who are members of this project.")
    modified_at: Optional[datetime] = Field(default=None, description="The time at which this project was last modified. *Note: This does not currently reflect any changes in associations such as tasks or comments that may have been added or removed from the project.*")
    notes: Optional[StrictStr] = Field(default=None, description="Free-form textual information associated with the project (ie., its description).")
    public: Optional[StrictBool] = Field(default=None, description="*Deprecated:* new integrations use `privacy_setting` instead.")
    privacy_setting: Optional[StrictStr] = Field(default=None, description="The privacy setting of the project. *Note: Administrators in your organization may restrict the values of `privacy_setting`.*")
    start_on: Optional[date] = Field(default=None, description="The day on which work for this project begins, or null if the project has no start date. This takes a date with `YYYY-MM-DD` format. *Note: `due_on` or `due_at` must be present in the request when setting or unsetting the `start_on` parameter. Additionally, `start_on` and `due_on` cannot be the same date.*")
    default_access_level: Optional[StrictStr] = Field(default=None, description="The default access for users or teams who join or are added as members to the project.")
    minimum_access_level_for_customization: Optional[StrictStr] = Field(default=None, description="The minimum access level needed for project members to modify this project's workflow and appearance.")
    minimum_access_level_for_sharing: Optional[StrictStr] = Field(default=None, description="The minimum access level needed for project members to share the project and manage project memberships.")
    __properties: ClassVar[List[str]] = ["gid", "resource_type", "name", "archived", "color", "created_at", "current_status", "current_status_update", "custom_field_settings", "default_view", "due_date", "due_on", "html_notes", "members", "modified_at", "notes", "public", "privacy_setting", "start_on", "default_access_level", "minimum_access_level_for_customization", "minimum_access_level_for_sharing"]

    @field_validator('color')
    def color_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['dark-pink', 'dark-green', 'dark-blue', 'dark-red', 'dark-teal', 'dark-brown', 'dark-orange', 'dark-purple', 'dark-warm-gray', 'light-pink', 'light-green', 'yellow-orange', 'yellow-green', 'yellow', 'red', 'purple', 'pink', 'orange', 'magenta', 'indigo', 'hot-pink', 'green', 'cool-gray', 'blue-green', 'blue', 'white', 'aqua', 'light-blue', 'light-red', 'light-teal', 'light-brown', 'light-orange', 'light-purple', 'light-warm-gray', 'none']):
            raise ValueError("must be one of enum values ('dark-pink', 'dark-green', 'dark-blue', 'dark-red', 'dark-teal', 'dark-brown', 'dark-orange', 'dark-purple', 'dark-warm-gray', 'light-pink', 'light-green', 'yellow-orange', 'yellow-green', 'yellow', 'red', 'purple', 'pink', 'orange', 'magenta', 'indigo', 'hot-pink', 'green', 'cool-gray', 'blue-green', 'blue', 'white', 'aqua', 'light-blue', 'light-red', 'light-teal', 'light-brown', 'light-orange', 'light-purple', 'light-warm-gray', 'none')")
        return value

    @field_validator('default_view')
    def default_view_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['list', 'board', 'calendar', 'timeline']):
            raise ValueError("must be one of enum values ('list', 'board', 'calendar', 'timeline')")
        return value

    @field_validator('privacy_setting')
    def privacy_setting_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['public_to_workspace', 'private_to_team', 'private']):
            raise ValueError("must be one of enum values ('public_to_workspace', 'private_to_team', 'private')")
        return value

    @field_validator('default_access_level')
    def default_access_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['admin', 'editor', 'commenter', 'viewer']):
            raise ValueError("must be one of enum values ('admin', 'editor', 'commenter', 'viewer')")
        return value

    @field_validator('minimum_access_level_for_customization')
    def minimum_access_level_for_customization_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['admin', 'editor']):
            raise ValueError("must be one of enum values ('admin', 'editor')")
        return value

    @field_validator('minimum_access_level_for_sharing')
    def minimum_access_level_for_sharing_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['admin', 'editor']):
            raise ValueError("must be one of enum values ('admin', 'editor')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ProjectBase from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "gid",
            "resource_type",
            "created_at",
            "custom_field_settings",
            "members",
            "modified_at",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of current_status
        if self.current_status:
            _dict['current_status'] = self.current_status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of current_status_update
        if self.current_status_update:
            _dict['current_status_update'] = self.current_status_update.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in custom_field_settings (list)
        _items = []
        if self.custom_field_settings:
            for _item_custom_field_settings in self.custom_field_settings:
                if _item_custom_field_settings:
                    _items.append(_item_custom_field_settings.to_dict())
            _dict['custom_field_settings'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in members (list)
        _items = []
        if self.members:
            for _item_members in self.members:
                if _item_members:
                    _items.append(_item_members.to_dict())
            _dict['members'] = _items
        # set to None if color (nullable) is None
        # and model_fields_set contains the field
        if self.color is None and "color" in self.model_fields_set:
            _dict['color'] = None

        # set to None if due_date (nullable) is None
        # and model_fields_set contains the field
        if self.due_date is None and "due_date" in self.model_fields_set:
            _dict['due_date'] = None

        # set to None if due_on (nullable) is None
        # and model_fields_set contains the field
        if self.due_on is None and "due_on" in self.model_fields_set:
            _dict['due_on'] = None

        # set to None if start_on (nullable) is None
        # and model_fields_set contains the field
        if self.start_on is None and "start_on" in self.model_fields_set:
            _dict['start_on'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ProjectBase from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "gid": obj.get("gid"),
            "resource_type": obj.get("resource_type"),
            "name": obj.get("name"),
            "archived": obj.get("archived"),
            "color": obj.get("color"),
            "created_at": obj.get("created_at"),
            "current_status": ProjectBaseAllOfCurrentStatus.from_dict(obj["current_status"]) if obj.get("current_status") is not None else None,
            "current_status_update": ProjectBaseAllOfCurrentStatusUpdate.from_dict(obj["current_status_update"]) if obj.get("current_status_update") is not None else None,
            "custom_field_settings": [CustomFieldSettingResponse.from_dict(_item) for _item in obj["custom_field_settings"]] if obj.get("custom_field_settings") is not None else None,
            "default_view": obj.get("default_view"),
            "due_date": obj.get("due_date"),
            "due_on": obj.get("due_on"),
            "html_notes": obj.get("html_notes"),
            "members": [UserCompact.from_dict(_item) for _item in obj["members"]] if obj.get("members") is not None else None,
            "modified_at": obj.get("modified_at"),
            "notes": obj.get("notes"),
            "public": obj.get("public"),
            "privacy_setting": obj.get("privacy_setting"),
            "start_on": obj.get("start_on"),
            "default_access_level": obj.get("default_access_level"),
            "minimum_access_level_for_customization": obj.get("minimum_access_level_for_customization"),
            "minimum_access_level_for_sharing": obj.get("minimum_access_level_for_sharing")
        })
        return _obj


