# coding: utf-8

"""
    Asana

    This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from asana_asyncio.models.custom_field_compact import CustomFieldCompact
from asana_asyncio.models.custom_field_setting_response import CustomFieldSettingResponse
from asana_asyncio.models.portfolio_response_all_of_workspace import PortfolioResponseAllOfWorkspace
from asana_asyncio.models.project_template_compact import ProjectTemplateCompact
from asana_asyncio.models.status_update_compact import StatusUpdateCompact
from asana_asyncio.models.user_compact import UserCompact
from typing import Optional, Set
from typing_extensions import Self

class PortfolioResponse(BaseModel):
    """
    PortfolioResponse
    """ # noqa: E501
    gid: Optional[StrictStr] = Field(default=None, description="Globally unique identifier of the resource, as a string.")
    resource_type: Optional[StrictStr] = Field(default=None, description="The base type of this resource.")
    name: Optional[StrictStr] = Field(default=None, description="The name of the portfolio.")
    archived: Optional[StrictBool] = Field(default=None, description="[Opt In](/docs/inputoutput-options). True if the portfolio is archived, false if not. Archived portfolios do not show in the UI by default and may be treated differently for queries.")
    color: Optional[StrictStr] = Field(default=None, description="Color of the portfolio.")
    created_at: Optional[datetime] = Field(default=None, description="The time at which this resource was created.")
    created_by: Optional[UserCompact] = None
    custom_field_settings: Optional[List[CustomFieldSettingResponse]] = Field(default=None, description="<p><strong style=\"color: #4573D2\">Full object requires scope: </strong><code>custom_fields:read</code></p>  Array of custom field settings applied to the portfolio.")
    current_status_update: Optional[StatusUpdateCompact] = Field(default=None, description="The latest `status_update` posted to this portfolio.")
    due_on: Optional[date] = Field(default=None, description="The localized day on which this portfolio is due. This takes a date with format YYYY-MM-DD.")
    custom_fields: Optional[List[CustomFieldCompact]] = Field(default=None, description="<p><strong style=\"color: #4573D2\">Full object requires scope: </strong><code>custom_fields:read</code></p>  Array of Custom Fields.")
    members: Optional[List[UserCompact]] = None
    owner: Optional[UserCompact] = None
    start_on: Optional[date] = Field(default=None, description="The day on which work for this portfolio begins, or null if the portfolio has no start date. This takes a date with `YYYY-MM-DD` format. *Note: `due_on` must be present in the request when setting or unsetting the `start_on` parameter. Additionally, `start_on` and `due_on` cannot be the same date.*")
    workspace: Optional[PortfolioResponseAllOfWorkspace] = None
    permalink_url: Optional[StrictStr] = Field(default=None, description="A url that points directly to the object within Asana.")
    public: Optional[StrictBool] = Field(default=None, description="True if the portfolio is public to its workspace members.")
    default_access_level: Optional[StrictStr] = Field(default=None, description="The default access level when inviting new members to the portfolio")
    privacy_setting: Optional[StrictStr] = Field(default=None, description="The privacy setting of the portfolio. *Note: Administrators in your organization may restrict the values of `privacy_setting`.*")
    project_templates: Optional[List[ProjectTemplateCompact]] = Field(default=None, description="Array of project templates that are in the portfolio")
    __properties: ClassVar[List[str]] = ["gid", "resource_type", "name", "archived", "color", "created_at", "created_by", "custom_field_settings", "current_status_update", "due_on", "custom_fields", "members", "owner", "start_on", "workspace", "permalink_url", "public", "default_access_level", "privacy_setting", "project_templates"]

    @field_validator('color')
    def color_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['dark-pink', 'dark-green', 'dark-blue', 'dark-red', 'dark-teal', 'dark-brown', 'dark-orange', 'dark-purple', 'dark-warm-gray', 'light-pink', 'light-green', 'yellow-orange', 'yellow-green', 'yellow', 'red', 'purple', 'pink', 'orange', 'magenta', 'indigo', 'hot-pink', 'green', 'cool-gray', 'blue-green', 'blue', 'white', 'aqua', 'light-blue', 'light-red', 'light-teal', 'light-brown', 'light-orange', 'light-purple', 'light-warm-gray']):
            raise ValueError("must be one of enum values ('dark-pink', 'dark-green', 'dark-blue', 'dark-red', 'dark-teal', 'dark-brown', 'dark-orange', 'dark-purple', 'dark-warm-gray', 'light-pink', 'light-green', 'yellow-orange', 'yellow-green', 'yellow', 'red', 'purple', 'pink', 'orange', 'magenta', 'indigo', 'hot-pink', 'green', 'cool-gray', 'blue-green', 'blue', 'white', 'aqua', 'light-blue', 'light-red', 'light-teal', 'light-brown', 'light-orange', 'light-purple', 'light-warm-gray')")
        return value

    @field_validator('default_access_level')
    def default_access_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['admin', 'editor', 'viewer']):
            raise ValueError("must be one of enum values ('admin', 'editor', 'viewer')")
        return value

    @field_validator('privacy_setting')
    def privacy_setting_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['public_to_domain', 'members_only']):
            raise ValueError("must be one of enum values ('public_to_domain', 'members_only')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PortfolioResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "gid",
            "resource_type",
            "created_at",
            "members",
            "permalink_url",
            "project_templates",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of created_by
        if self.created_by:
            _dict['created_by'] = self.created_by.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in custom_field_settings (list)
        _items = []
        if self.custom_field_settings:
            for _item_custom_field_settings in self.custom_field_settings:
                if _item_custom_field_settings:
                    _items.append(_item_custom_field_settings.to_dict())
            _dict['custom_field_settings'] = _items
        # override the default output from pydantic by calling `to_dict()` of current_status_update
        if self.current_status_update:
            _dict['current_status_update'] = self.current_status_update.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in custom_fields (list)
        _items = []
        if self.custom_fields:
            for _item_custom_fields in self.custom_fields:
                if _item_custom_fields:
                    _items.append(_item_custom_fields.to_dict())
            _dict['custom_fields'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in members (list)
        _items = []
        if self.members:
            for _item_members in self.members:
                if _item_members:
                    _items.append(_item_members.to_dict())
            _dict['members'] = _items
        # override the default output from pydantic by calling `to_dict()` of owner
        if self.owner:
            _dict['owner'] = self.owner.to_dict()
        # override the default output from pydantic by calling `to_dict()` of workspace
        if self.workspace:
            _dict['workspace'] = self.workspace.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in project_templates (list)
        _items = []
        if self.project_templates:
            for _item_project_templates in self.project_templates:
                if _item_project_templates:
                    _items.append(_item_project_templates.to_dict())
            _dict['project_templates'] = _items
        # set to None if current_status_update (nullable) is None
        # and model_fields_set contains the field
        if self.current_status_update is None and "current_status_update" in self.model_fields_set:
            _dict['current_status_update'] = None

        # set to None if due_on (nullable) is None
        # and model_fields_set contains the field
        if self.due_on is None and "due_on" in self.model_fields_set:
            _dict['due_on'] = None

        # set to None if start_on (nullable) is None
        # and model_fields_set contains the field
        if self.start_on is None and "start_on" in self.model_fields_set:
            _dict['start_on'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PortfolioResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "gid": obj.get("gid"),
            "resource_type": obj.get("resource_type"),
            "name": obj.get("name"),
            "archived": obj.get("archived"),
            "color": obj.get("color"),
            "created_at": obj.get("created_at"),
            "created_by": UserCompact.from_dict(obj["created_by"]) if obj.get("created_by") is not None else None,
            "custom_field_settings": [CustomFieldSettingResponse.from_dict(_item) for _item in obj["custom_field_settings"]] if obj.get("custom_field_settings") is not None else None,
            "current_status_update": StatusUpdateCompact.from_dict(obj["current_status_update"]) if obj.get("current_status_update") is not None else None,
            "due_on": obj.get("due_on"),
            "custom_fields": [CustomFieldCompact.from_dict(_item) for _item in obj["custom_fields"]] if obj.get("custom_fields") is not None else None,
            "members": [UserCompact.from_dict(_item) for _item in obj["members"]] if obj.get("members") is not None else None,
            "owner": UserCompact.from_dict(obj["owner"]) if obj.get("owner") is not None else None,
            "start_on": obj.get("start_on"),
            "workspace": PortfolioResponseAllOfWorkspace.from_dict(obj["workspace"]) if obj.get("workspace") is not None else None,
            "permalink_url": obj.get("permalink_url"),
            "public": obj.get("public"),
            "default_access_level": obj.get("default_access_level"),
            "privacy_setting": obj.get("privacy_setting"),
            "project_templates": [ProjectTemplateCompact.from_dict(_item) for _item in obj["project_templates"]] if obj.get("project_templates") is not None else None
        })
        return _obj


